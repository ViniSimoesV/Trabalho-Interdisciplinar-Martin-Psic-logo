// Configurações da Google Calendar API
const GOOGLE_CALENDAR_CONFIG = {
    apiKey: 'AIzaSyAvwycz-EZuYwx_-CGlNebRRGO5nVON--g', // Substitua pela sua API Key
    clientId: '398480770111-64bv24rh8ftvopf73pn9uivdgq4faks2.apps.googleusercontent.com', // Substitua pelo seu Client ID
    discoveryDoc: 'https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest',
    scopes: 'https://www.googleapis.com/auth/calendar'
};

let gapi;
let tokenClient;
let isGapiInitialized = false;
let isGisInitialized = false;


// Função para converter string de tempo (HH:MM ou HH:MM:SS) em minutos
function timeStringToMinutes(timeString) {
    if (!timeString) return 0;
    // Se tiver segundos, remova-os
    const time = timeString.length === 8 ? timeString.substring(0, 5) : timeString;
    const [hours, minutes] = time.split(':').map(Number);
    return hours * 60 + minutes;
}

// JavaScript para a página de Gerenciar Horários
// Unifica inicialização da UI e do FullCalendar
document.addEventListener('DOMContentLoaded', function() {
    // Elementos do formulário
    const btnAdicionar = document.getElementById('btnAdicionar');
    const btnRemover = document.getElementById('btnRemover');
    const diaSemana = document.getElementById('diaSemana');
    const horaInicio = document.getElementById('horaInicio');
    const horaFim = document.getElementById('horaFim');
    const alcanceSelect = document.getElementById('alcance');
    const selectRemover = document.getElementById('horarioSelecionado');

    // Inicializa FullCalendar
    const calendarEl = document.getElementById('calendar');
    const calendar = new FullCalendar.Calendar(calendarEl, {
        initialView: 'timeGridWeek',
        locale: 'pt-br',
        slotMinTime: '07:00:00',
        slotMaxTime: '22:00:00',
        allDaySlot: false,
        height: 650,
        events: [],
        eventClick: function(info) {
            const event = info.event;
            const extendedProps = event.extendedProps;

            if (extendedProps.type === 'agendamento') {
                // Mostrar modal padronizado com detalhes do agendamento
                showCancelModal({
                    agendamentoId: extendedProps.agendamentoId,
                    paciente: extendedProps.paciente,
                    email: extendedProps.email,
                    telefone: extendedProps.telefone,
                    data: event.start.toLocaleDateString('pt-BR'),
                    horario: event.start.toLocaleTimeString('pt-BR', {hour: '2-digit', minute: '2-digit'})
                }, event);
            } else if (extendedProps.type === 'disponivel') {
                // Mostrar que é um horário disponível
                alert('Horário disponível para agendamento');
            }
        }
    });
    calendar.render();

    // Expor função de recarregar horários para uso externo (cancelamento, etc.)
    window.carregarHorariosDoServidor = carregarHorariosDoServidor;

    // Setup do modal de cancelamento: refs e helpers (inicialização tardia)
    let modal = document.getElementById('modalCancelamento');
    let modalBody = document.getElementById('modalBody');
    let modalClose = document.getElementById('modalClose');
    let confirmCancel = document.getElementById('confirmCancel');
    let rescheduleBtn = document.getElementById('rescheduleBtn');
    let modalActions = null;
    let _modalListenersBound = false;
    let _rescheduleState = { previousHtml: null, saveBtn: null, backBtn: null };

    // Garante que as refs do modal existam (chame antes de usar)
    function ensureModalElements() {
        if (!modal) modal = document.getElementById('modalCancelamento');
        if (!modalBody) modalBody = document.getElementById('modalBody');
        if (!modalClose) modalClose = document.getElementById('modalClose');
        if (!confirmCancel) confirmCancel = document.getElementById('confirmCancel');
        if (!rescheduleBtn) rescheduleBtn = document.getElementById('rescheduleBtn');
        if (modal && !modalActions) modalActions = modal.querySelector('.modal-actions');
    }

    // guarda referência temporária ao evento e id
    let _modalState = { agendamentoId: null, eventRef: null };

    function showCancelModal(data, eventRef) {
        ensureModalElements();
        if (!modal) return;
        _modalState.agendamentoId = data.agendamentoId;
        _modalState.eventRef = eventRef;

        modalBody.innerHTML = `
            <p><strong>Paciente:</strong> ${data.paciente || 'Não informado'}</p>
            <p><strong>Email:</strong> ${data.email || 'Não informado'}</p>
            <p><strong>Telefone:</strong> ${data.telefone || 'Não informado'}</p>
            <p><strong>Data:</strong> ${data.data}</p>
            <p><strong>Horário:</strong> ${data.horario}</p>
            <p>Deseja realmente cancelar este agendamento?</p>
        `;

        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');

        // Bind listeners lazy (apenas uma vez) caso não tenham sido adicionados
        if (!_modalListenersBound) {
            if (modalClose) modalClose.addEventListener('click', closeCancelModal);
            if (modal) modal.addEventListener('click', function(e) { if (e.target === modal) closeCancelModal(); });
            if (confirmCancel) confirmCancel.addEventListener('click', async function() {
                const id = _modalState.agendamentoId;
                const ev = _modalState.eventRef;
                if (!id) return;
                await cancelarAgendamento(id, ev);
                closeCancelModal();
            });
            if (rescheduleBtn) rescheduleBtn.addEventListener('click', function() {
                enterRescheduleMode();
            });
            _modalListenersBound = true;
        }
    }

    // --- Reagendamento ---
    function enterRescheduleMode() {
        ensureModalElements();
        if (!modal || !_modalState.eventRef) return;

        // Guardar HTML atual para voltar depois
        _rescheduleState.previousHtml = modalBody ? modalBody.innerHTML : '';

        // Preencher formulário simples com data e hora atuais do evento
        const ev = _modalState.eventRef;
        const start = ev && ev.start ? new Date(ev.start) : null;
        const defaultDate = start ? start.toISOString().split('T')[0] : '';
        const defaultTime = start ? start.toTimeString().substring(0,5) : '';

        if (modalBody) {
            modalBody.innerHTML = `
                <div class="reschedule-form">
                    <label for="newDate"><strong>Nova data</strong></label>
                    <input type="date" id="newDate" value="${defaultDate}" />
                    <label for="newTime"><strong>Novo horário</strong></label>
                    <input type="time" id="newTime" value="${defaultTime}" />
                    <p style="margin-top:8px; font-size:0.9em; color:#444;">Preencha a nova data e horário desejados e clique em "Salvar Reagendamento".</p>

                    
                </div>
            `;
        }

        // Ajustar botões na área de ações
        if (modalActions) {
            // esconder botões originais
            if (confirmCancel) confirmCancel.style.display = 'none';
            if (rescheduleBtn) rescheduleBtn.style.display = 'none';

            // criar botão salvar
            const save = document.createElement('button');
            save.id = 'saveReschedule';
            save.className = 'btn-adicionar';
            save.textContent = 'Salvar Reagendamento';
            // criar botão voltar
            const back = document.createElement('button');
            back.id = 'backFromReschedule';
            back.className = 'btn-remover';
            back.textContent = 'Voltar';

            modalActions.appendChild(save);
            modalActions.appendChild(back);

            _rescheduleState.saveBtn = save;
            _rescheduleState.backBtn = back;

            save.addEventListener('click', saveReschedule);
            back.addEventListener('click', exitRescheduleMode);
        }
    }

    function exitRescheduleMode() {
        ensureModalElements();
        if (!modalBody || !modalActions) return;

        // remover botões criados
        if (_rescheduleState.saveBtn) {
            _rescheduleState.saveBtn.removeEventListener('click', saveReschedule);
            modalActions.removeChild(_rescheduleState.saveBtn);
        }
        if (_rescheduleState.backBtn) {
            _rescheduleState.backBtn.removeEventListener('click', exitRescheduleMode);
            modalActions.removeChild(_rescheduleState.backBtn);
        }

        // restaurar botões originais
        if (confirmCancel) confirmCancel.style.display = '';
        if (rescheduleBtn) rescheduleBtn.style.display = '';

        // restaurar HTML anterior
        modalBody.innerHTML = _rescheduleState.previousHtml || '';
        _rescheduleState.previousHtml = null;
        _rescheduleState.saveBtn = null;
        _rescheduleState.backBtn = null;
    }

    async function saveReschedule() {
    ensureModalElements();
    if (!_modalState.agendamentoId) {
        alert('ID do agendamento ausente. Não é possível reagendar.');
        return;
    }

    const newDate = document.getElementById('newDate').value;
    const newTime = document.getElementById('newTime').value;

    if (!newDate || !newTime) {
        alert('Preencha nova data e horário.');
        return;
    }

    const payload = {
        novaDataHora: `${newDate}T${newTime}`
    };

    try {
        const headers = { 'Content-Type': 'application/json' };
        const usuCodigo = localStorage.getItem('usuCodigo');
        if (usuCodigo) headers['usuCodigo'] = usuCodigo;

        const res = await fetch(`/api/horarios/agendamentos/${_modalState.agendamentoId}`, {
            method: 'PATCH',
            headers,
            body: JSON.stringify(payload)
        });

        if (res.ok) {
            alert('Agendamento reagendado com sucesso.');
            exitRescheduleMode();
            closeCancelModal();
            if (window.carregarHorariosDoServidor)
                await window.carregarHorariosDoServidor();
        } else {
            console.error('Erro ao reagendar:', res.status, await res.text());
            alert('Erro ao reagendar. Verifique o console para detalhes.');
        }
    } catch (err) {
        console.error('Erro ao reagendar (fetch):', err);
        alert('Erro ao conectar com o servidor ao tentar reagendar.');
    }
}


    function closeCancelModal() {
        ensureModalElements();
        if (!modal) return;
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        _modalState = { agendamentoId: null, eventRef: null };
        if (modalBody) modalBody.innerHTML = '';
    }
    // Observação: listeners do modal são adicionados de forma lazy quando o modal é exibido.

    // Helper para somar meses (utilizado por carregamento e adição)
    function addMonths(dt, months) {
        const d = new Date(dt);
        const targetMonth = d.getMonth() + months;
        d.setMonth(targetMonth);
        if (d.getMonth() !== ((targetMonth) % 12)) {
            d.setDate(0);
        }
        return d;
    }

    // Carrega horários do servidor ao iniciar
    // Carrega horários do servidor ao iniciar - VERSÃO CORRIGIDA
async function carregarHorariosDoServidor() {
    try {
        // Limpar eventos existentes
        if (calendar) {
            const eventosExistentes = calendar.getEvents();
            eventosExistentes.forEach(ev => ev.remove());
        }
        if (selectRemover) {
            selectRemover.innerHTML = '<option value="">Selecione um horário</option>';
        }

        // Buscar dados
        const [resHorarios, resAgendamentos] = await Promise.all([
            fetch('/api/horarios'),
            fetch('/agendamentos/psicologo')
        ]);

        if (!resHorarios.ok) return;
        const listHorarios = await resHorarios.json();
        let agendamentos = [];
        if (resAgendamentos.ok) {
            agendamentos = await resAgendamentos.json();
        }

        // ⭐⭐ PRIMEIRO: Criar mapa de horários ocupados
        const horariosOcupadosMap = new Map();
        agendamentos.forEach(ag => {
            const dataKey = ag.data; // Formato YYYY-MM-DD
            const horarioKey = ag.horario.substring(0, 5); // Formato HH:mm
            
            if (!horariosOcupadosMap.has(dataKey)) {
                horariosOcupadosMap.set(dataKey, new Set());
            }
            horariosOcupadosMap.get(dataKey).add(horarioKey);
        });

        // ⭐⭐ SEGUNDO: Adicionar apenas horários NÃO OCUPADOS
        listHorarios.forEach(item => {
            const diasSemana = {
                'DOMINGO': 0, 'SEGUNDA_FEIRA': 1, 'TERCA_FEIRA': 2, 
                'QUARTA_FEIRA': 3, 'QUINTA_FEIRA': 4, 'SEXTA_FEIRA': 5, 'SABADO': 6
            };
            const diaNumero = diasSemana[item.diaSemana];

            const [hIni, mIni] = item.horaInicio.split(':');
            const [hFim, mFim] = item.horaFim.split(':');

            const repeticao = (item.repeticao || 'ONCE').toUpperCase();
            const alcance = (item.alcance || 'ANUAL').toString().toUpperCase();

            const hoje = new Date();
            const primeiro = new Date(hoje);
            primeiro.setDate(hoje.getDate() - hoje.getDay() + diaNumero);

            // Função para verificar se horário está ocupado
            function horarioEstaOcupado(dataObj, horaInicio) {
                const dataStr = dataObj.toISOString().split('T')[0];
                const horaStr = horaInicio.substring(0, 5);
                
                return horariosOcupadosMap.has(dataStr) && 
                       horariosOcupadosMap.get(dataStr).has(horaStr);
            }

            // Gerar eventos baseado na repetição
            function gerarEventoDisponivel(dataOcorr) {
                // VERIFICAR SE ESTÁ OCUPADO ANTES DE ADICIONAR
                if (!horarioEstaOcupado(dataOcorr, item.horaInicio)) {
                    const start = new Date(dataOcorr);
                    start.setHours(parseInt(hIni), parseInt(mIni), 0, 0);
                    const end = new Date(dataOcorr);
                    end.setHours(parseInt(hFim), parseInt(mFim), 0, 0);
                    
                    calendar.addEvent({ 
                        title: 'Disponível', 
                        start, 
                        end, 
                        backgroundColor: '#4caf50',
                        borderColor: '#388e3c',
                        extendedProps: { 
                            scheduleId: item.id,
                            type: 'disponivel'
                        } 
                    });
                }
            }

            // Lógica de repetição
            if (repeticao === 'WEEKLY') {
                const limiteSemanas = (alcance === 'ANUAL' || alcance === 'ANNUAL') ? 52 : 4;
                for (let i = 0; i < limiteSemanas; i++) {
                    const dataOcorr = new Date(primeiro);
                    dataOcorr.setDate(primeiro.getDate() + i * 7);
                    gerarEventoDisponivel(dataOcorr);
                }
            } else if (repeticao === 'BIWEEKLY' || repeticao === 'BIWEEK') {
                const limiteSemanas = (alcance === 'ANUAL' || alcance === 'ANNUAL') ? 26 : 2;
                for (let i = 0; i < limiteSemanas; i++) {
                    const dataOcorr = new Date(primeiro);
                    dataOcorr.setDate(primeiro.getDate() + i * 14);
                    gerarEventoDisponivel(dataOcorr);
                }
            } else {
                // ONCE
                gerarEventoDisponivel(primeiro);
            }

            // Atualizar select de remoção
            if (selectRemover) {
                const opt = document.createElement('option');
                opt.value = item.id;
                opt.textContent = `${item.diaSemana} ${item.horaInicio} - ${item.horaFim}`;
                selectRemover.appendChild(opt);
            }
        });

        // ⭐⭐ TERCEIRO: Adicionar agendamentos (SEM CONFLITO)
        agendamentos.forEach(ag => {
            const start = new Date(ag.data + 'T' + ag.horario);
            const end = new Date(start.getTime() + 60 * 60 * 1000);

            calendar.addEvent({
                title: `Agendado: ${ag.paciente}`,
                start: start,
                end: end,
                backgroundColor: '#ff9800',
                borderColor: '#f57c00',
                extendedProps: {
                    agendamentoId: ag.agendamentoID,
                    type: 'agendamento',
                    paciente: ag.paciente,
                    telefone: ag.telefone,
                    email: ag.email
                }
            });
        });

    } catch (err) {
        console.error('Erro ao carregar horários do servidor:', err);
    }
}


    carregarHorariosDoServidor();

    // Popula selectRemover com horários já adicionados no cliente (ou do servidor se implementar GET)
    function adicionarOptionRemover(dia, inicio, fim) {
        if (!selectRemover) return;
        const option = document.createElement('option');
        // Até o momento, sem id. Será substituído quando salvar no servidor.
        option.value = `${dia} ${inicio}-${fim}`;
        option.textContent = `${dia} ${inicio} - ${fim}`;
        selectRemover.appendChild(option);
    }

    // Handler de adicionar: atualiza o FullCalendar e envia ao backend
    async function handleAdicionar() {
        const dia = diaSemana.value;
        const inicio = horaInicio.value;
        const fim = horaFim.value;
    const repeticao = document.getElementById('repeticao') ? document.getElementById('repeticao').value : 'once';
    const alcance = alcanceSelect ? alcanceSelect.value : 'anual';

        if (!dia || !inicio || !fim) {
            alert('Preencha todos os campos!');
            return;
        }

        if (inicio >= fim) {
            alert('Horário de início deve ser anterior ao de fim.');
            return;
        }

        // Converte dia para número para posicionar no calendário
        const diasSemana = {
            'domingo': 0,
            'segunda-feira': 1,
            'terca-feira': 2,
            'quarta-feira': 3,
            'quinta-feira': 4,
            'sexta-feira': 5,
            'sabado': 6
        };

        const hoje = new Date();
        const dataReferencia = new Date(hoje);
        const diaNumero = diasSemana[dia];
        dataReferencia.setDate(hoje.getDate() - hoje.getDay() + diaNumero);

        const [hIni, mIni] = inicio.split(':');
        const [hFim, mFim] = fim.split(':');
        const start = new Date(dataReferencia);
        start.setHours(parseInt(hIni), parseInt(mIni));
        const end = new Date(dataReferencia);
        end.setHours(parseInt(hFim), parseInt(mFim));

        // Função auxiliar para adicionar um evento ao calendário (cliente)
        function adicionarEventoCliente(startDate) {
            const ev = {
                title: 'Atendimento',
                start: new Date(startDate),
                end: new Date(new Date(startDate).getTime() + (end.getTime() - start.getTime())),
                backgroundColor: '#4caf50',
                borderColor: '#388e3c'
            };
            calendar.addEvent(ev);
        }
        // Verificação de sobreposição: primeiro calcular todas as datas candidatas e checar
        function hasOverlap(candidateStart, candidateEnd) {
            const eventos = calendar.getEvents();
            for (const ev of eventos) {
                if (!ev.start || !ev.end) continue;
                const es = ev.start;
                const ee = ev.end;
                if (es.getTime() < candidateEnd.getTime() && candidateStart.getTime() < ee.getTime()) {
                    return true;
                }
            }
            return false;
        }

        function formatDateTime(d) {
            return d.toLocaleDateString('pt-BR') + ' ' + d.toLocaleTimeString('pt-BR', {hour: '2-digit', minute: '2-digit'});
        }

        // gera array de datas candidatas (somente starts) sem adicionar ainda
        const candidateStarts = [];
        if (repeticao === 'once') {
            candidateStarts.push(new Date(start));
        } else if (repeticao === 'weekly') {
            if (alcance === 'anual') {
                for (let i = 0; i < 52; i++) {
                    const d = new Date(start);
                    d.setDate(d.getDate() + i * 7);
                    candidateStarts.push(d);
                }
            } else {
                const limite = addMonths(start, 1);
                let curr = new Date(start);
                while (curr <= limite) {
                    candidateStarts.push(new Date(curr));
                    curr = new Date(curr);
                    curr.setDate(curr.getDate() + 7);
                }
            }
        } else if (repeticao === 'biweekly') {
            if (alcance === 'anual') {
                for (let i = 0; i < 26; i++) {
                    const d = new Date(start);
                    d.setDate(d.getDate() + i * 14);
                    candidateStarts.push(d);
                }
            } else {
                const limite = addMonths(start, 1);
                let curr = new Date(start);
                while (curr <= limite) {
                    candidateStarts.push(new Date(curr));
                    curr = new Date(curr);
                    curr.setDate(curr.getDate() + 14);
                }
            }
        }

        // calcular duração do evento
        const durationMs = end.getTime() - start.getTime();

        // checar sobreposições
        for (const cs of candidateStarts) {
            const candidateStart = new Date(cs);
            const candidateEnd = new Date(candidateStart.getTime() + durationMs);
            if (hasOverlap(candidateStart, candidateEnd)) {
                alert(`Conflito: o horário ${formatDateTime(candidateStart)} - ${formatDateTime(candidateEnd)} sobrepõe um horário já existente. Cancelando operação.`);
                return; // aborta toda a operação de adicionar
            }
        }

        // se chegou aqui, não há sobreposição -> adiciona os eventos ao calendário
        for (const cs of candidateStarts) {
            adicionarEventoCliente(cs);
        }

        // popular select de remoção com a primeira ocorrência para permitir remoção local
        adicionarOptionRemover(dia, inicio, fim);

        // Envia ao backend para persistir
        try {
            const payload = {
                diaSemana: dia,
                horaInicio: inicio,
                horaFim: fim,
                repeticao: repeticao,
                alcance: alcance // informa ao backend (se suportado) o alcance: 'mensal' ou 'anual'
            };

            const res = await fetch('/api/horarios', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!res.ok) {
                const text = await res.text();
                console.error('Erro ao salvar no backend:', res.status, text);
                alert('Erro ao salvar horário no servidor. Veja console para detalhes.');
            } else {
                const saved = await res.json();
                console.log('Salvo no backend:', saved);
                // recarregar do servidor para manter sincronizado
                await carregarHorariosDoServidor();
                alert('Horário salvo com sucesso.');
            }
        } catch (err) {
            console.error('Fetch error:', err);
            alert('Erro ao conectar com o servidor.');
        }

        // limpa campos
        diaSemana.value = '';
        horaInicio.value = '';
        horaFim.value = '';
    }

    // Handler remover: remove do calendar e do select
    function handleRemover() {
        const valor = selectRemover ? selectRemover.value : '';
        if (!valor) {
            alert('Selecione o horário para remover!');
            return;
        }

        // Se o valor for numérico (id), chamamos DELETE no backend
        if (/^\d+$/.test(valor)) {
            const id = valor;
            fetch(`/api/horarios/${id}`, { method: 'DELETE' })
                .then(res => {
                    if (res.status === 204) {
                        // remover visualmente
                        const eventos = calendar.getEvents();
                        eventos.forEach(ev => {
                            // tenta remover apenas os eventos relacionados ao scheduleId retornado
                            try {
                                const sid = ev.extendedProps && ev.extendedProps.scheduleId;
                                if (sid && String(sid) === String(id)) {
                                    ev.remove();
                                }
                            } catch (e) {
                                // fallback para remover por título caso não exista extendedProps
                                if (ev.title === 'Atendimento') ev.remove();
                            }
                        });
                        const opcao = selectRemover.querySelector(`option[value="${valor}"]`);
                        if (opcao) opcao.remove();
                            // recarregar do servidor para sincronizar
                            carregarHorariosDoServidor();
                            alert('Horário removido do servidor e da agenda.');
                    } else {
                        return res.text().then(t => { throw new Error(t || res.status); });
                    }
                })
                .catch(err => {
                    console.error('Erro ao remover:', err);
                    alert('Erro ao remover no servidor. Veja console.');
                });
        } else {
            // valor sem id: apenas remove do UI
            const opcaoSelecionada = selectRemover ? selectRemover.querySelector(`option[value="${valor}"]`) : null;
            if (opcaoSelecionada) opcaoSelecionada.remove();
            const eventos = calendar.getEvents();
            eventos.forEach(ev => { if (ev.title === 'Atendimento') ev.remove(); });
            // recarregar lista local
            carregarHorariosDoServidor();
            alert('Horário removido (apenas UI).');
        }
    }

    if (btnAdicionar) btnAdicionar.addEventListener('click', handleAdicionar);
    if (btnRemover) btnRemover.addEventListener('click', handleRemover);

    // Atualização automática a cada 30 segundos para manter calendário sincronizado
    setInterval(() => {
        carregarHorariosDoServidor().catch(err => console.error('Erro ao atualizar horários automaticamente:', err));
    }, 30000);
});

    // Adicionar interatividade aos eventos da agenda
    const eventos = document.querySelectorAll('.evento');
    eventos.forEach(evento => {
        evento.addEventListener('click', function() {
            const horario = this.textContent.trim();
            console.log('Evento clicado:', horario);
            
            // Implementar ação ao clicar no evento
            if (this.classList.contains('disponivel')) {
                if (confirm('Deseja agendar este horário?')) {
                    alert('Funcionalidade de agendamento será implementada.');
                }
            } else if (this.classList.contains('agendado')) {
                if (confirm('Deseja visualizar detalhes deste agendamento?')) {
                    alert('Funcionalidade de detalhes será implementada.');
                }
            }
        });
    });

console.log('Página de gerenciar horários carregada.');

// Inicializar Google Calendar API quando disponível
initializeGoogleCalendarAPI();

// ============= GOOGLE CALENDAR API FUNCTIONS =============

// Inicialização do Google API
async function initializeGoogleCalendarAPI() {
    // Aguardar as APIs serem carregadas
    if (typeof gapi !== 'undefined') {
        await gapiLoaded();
    }
    if (typeof google !== 'undefined' && google.accounts) {
        gisLoaded();
    }
}

async function gapiLoaded() {
    await gapi.load('client', initializeGapiClient);
}

async function initializeGapiClient() {
    try {
        await gapi.client.init({
            apiKey: GOOGLE_CALENDAR_CONFIG.apiKey,
            discoveryDocs: [GOOGLE_CALENDAR_CONFIG.discoveryDoc]
        });
        isGapiInitialized = true;
        console.log('Google API inicializada com sucesso');
        updateGoogleCalendarStatus();
    } catch (error) {
        console.error('Erro ao inicializar Google API:', error);
        showCalendarMessage('Erro ao conectar com Google Calendar', 'error');
    }
}

function gisLoaded() {
    tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: GOOGLE_CALENDAR_CONFIG.clientId,
        scope: GOOGLE_CALENDAR_CONFIG.scopes,
        callback: handleAuthResponse
    });
    isGisInitialized = true;
    console.log('Google Identity Services inicializado');
    updateGoogleCalendarStatus();
}

function handleAuthResponse(resp) {
    if (resp.error !== undefined) {
        console.error('Erro de autenticação:', resp);
        showCalendarMessage('Erro na autenticação com Google', 'error');
        return;
    }
    
    console.log('Autenticação bem-sucedida');
    showCalendarMessage('Conectado ao Google Calendar!', 'success');
    updateGoogleCalendarStatus();
    loadCalendarEvents();
}

// Funções para conectar/desconectar Google Calendar
async function connectGoogleCalendar() {
    if (!isGapiInitialized || !isGisInitialized) {
        showCalendarMessage('APIs do Google não foram carregadas ainda', 'error');
        return;
    }

    try {
        if (gapi.client.getToken() === null) {
            tokenClient.requestAccessToken({prompt: 'consent'});
        } else {
            tokenClient.requestAccessToken({prompt: ''});
        }
    } catch (error) {
        console.error('Erro ao conectar:', error);
        showCalendarMessage('Erro ao conectar com Google Calendar', 'error');
    }
}

function disconnectGoogleCalendar() {
    const token = gapi.client.getToken();
    if (token !== null) {
        google.accounts.oauth2.revoke(token.access_token);
        gapi.client.setToken('');
        showCalendarMessage('Desconectado do Google Calendar', 'success');
        updateGoogleCalendarStatus();
    }
}

function updateGoogleCalendarStatus() {
    const connectBtn = document.getElementById('connectGoogleBtn');
    const disconnectBtn = document.getElementById('disconnectGoogleBtn');
    const statusElement = document.getElementById('calendarStatus');
    
    const isConnected = gapi && gapi.client.getToken() !== null;
    
    if (connectBtn && disconnectBtn && statusElement) {
        connectBtn.style.display = isConnected ? 'none' : 'inline-block';
        disconnectBtn.style.display = isConnected ? 'inline-block' : 'none';
        statusElement.textContent = isConnected ? 'Conectado' : 'Desconectado';
        statusElement.className = isConnected ? 'calendar-status connected' : 'calendar-status disconnected';
    }
}

// Função para carregar eventos do Google Calendar
async function loadCalendarEvents() {
    if (!gapi.client.getToken()) {
        showCalendarMessage('Faça login no Google Calendar primeiro', 'warning');
        return;
    }

    try {
        const response = await gapi.client.calendar.events.list({
            'calendarId': 'primary',
            'timeMin': new Date().toISOString(),
            'showDeleted': false,
            'singleEvents': true,
            'maxResults': 50,
            'orderBy': 'startTime'
        });

        const events = response.result.items;
        displayCalendarEvents(events);
        
    } catch (error) {
        console.error('Erro ao carregar eventos:', error);
        showCalendarMessage('Erro ao carregar eventos do Google Calendar', 'error');
    }
}

// Função para exibir eventos do calendário
function displayCalendarEvents(events) {
    const agendaContainer = document.querySelector('.agenda-container .agenda-slots') || 
                           document.querySelector('.agenda-container');
    
    if (!agendaContainer) return;

    // Limpar eventos existentes do Google
    const existingGoogleEvents = agendaContainer.querySelectorAll('.google-event');
    existingGoogleEvents.forEach(event => event.remove());

    if (events.length === 0) {
        console.log('Nenhum evento encontrado no Google Calendar');
        return;
    }

    events.forEach(event => {
        const start = event.start.dateTime || event.start.date;
        const end = event.end.dateTime || event.end.date;
        
        const eventDiv = document.createElement('div');
        eventDiv.className = 'agenda-slot google-event';
        eventDiv.innerHTML = `
            <div class="horario">${formatTime(start)} - ${formatTime(end)}</div>
            <div class="paciente">${event.summary || 'Evento sem título'}</div>
            <div class="status google-sync">Google Calendar</div>
        `;
        
        agendaContainer.appendChild(eventDiv);
    });
}

// Função para criar evento no Google Calendar
async function createGoogleCalendarEvent(eventData) {
    if (!gapi.client.getToken()) {
        showCalendarMessage('Faça login no Google Calendar primeiro', 'warning');
        return null;
    }

    try {
        const event = {
            'summary': `Consulta - ${eventData.paciente}`,
            'description': eventData.observacoes || 'Consulta psicológica',
            'start': {
                'dateTime': eventData.dataHoraInicio,
                'timeZone': 'America/Sao_Paulo'
            },
            'end': {
                'dateTime': eventData.dataHoraFim,
                'timeZone': 'America/Sao_Paulo'
            }
        };

        const response = await gapi.client.calendar.events.insert({
            'calendarId': 'primary',
            'resource': event
        });

        showCalendarMessage('Evento criado no Google Calendar!', 'success');
        return response.result;
        
    } catch (error) {
        console.error('Erro ao criar evento:', error);
        showCalendarMessage('Erro ao criar evento no Google Calendar', 'error');
        return null;
    }
}

// Função para mostrar mensagens do calendário
function showCalendarMessage(message, type) {
    // Remover mensagem anterior se existir
    const existingMessage = document.querySelector('.calendar-message');
    if (existingMessage) {
        existingMessage.remove();
    }

    const messageDiv = document.createElement('div');
    messageDiv.className = `calendar-message ${type}`;
    messageDiv.textContent = message;
    
    const agendaHeader = document.querySelector('.agenda-header');
    if (agendaHeader) {
        agendaHeader.appendChild(messageDiv);
        
        // Remover mensagem após 3 segundos
        setTimeout(() => {
            messageDiv.remove();
        }, 3000);
    }
}

// Função auxiliar para formatar horário
function formatTime(dateString) {
    const date = new Date(dateString);
    return date.toLocaleTimeString('pt-BR', { 
        hour: '2-digit', 
        minute: '2-digit' 
    });
}

// Adicionar eventos aos botões do Google Calendar quando a página carregar
window.addEventListener('load', function() {
    const connectBtn = document.getElementById('connectGoogleBtn');
    const disconnectBtn = document.getElementById('disconnectGoogleBtn');
    
    if (connectBtn) {
        connectBtn.addEventListener('click', connectGoogleCalendar);
    }
    
    if (disconnectBtn) {
        disconnectBtn.addEventListener('click', disconnectGoogleCalendar);
    }
});

// Função para redirecionar para outras páginas
function redirecionarPara(pagina) {
    window.location.href = pagina;
}

// Funções utilitárias
function formatarHorario(hora) {
    return hora.substring(0, 5); // Remove os segundos se houver
}

function formatarData(data) {
    const [ano, mes, dia] = data.split('-');
    return `${dia}/${mes}`;
}

function obterDataAtual() {
    const hoje = new Date();
    return hoje.toISOString().split('T')[0];
}



// Função para cancelar agendamento
async function cancelarAgendamento(agendamentoId, event) {
    try {
        const headers = {};
        const usuCodigo = localStorage.getItem('usuCodigo');
        if (usuCodigo) headers['usuCodigo'] = usuCodigo;

        const response = await fetch(`/agendamentos/${agendamentoId}`, {
            method: 'DELETE',
            headers
        });
        
        if (response.ok) {
            try { if (event && typeof event.remove === 'function') event.remove(); } catch (e) { /* ignore */ }
            alert('Agendamento cancelado com sucesso!');
            // Recarregar os dados: prefere a função exposta globalmente
            if (window.carregarHorariosDoServidor && typeof window.carregarHorariosDoServidor === 'function') {
                await window.carregarHorariosDoServidor();
            } else {
                // fallback simples
                window.location.reload();
            }
        } else {
            alert('Erro ao cancelar agendamento');
        }
    } catch (error) {
        console.error('Erro:', error);
        alert('Erro ao conectar com o servidor');
    }
}

// Redirecionar páginas (mantido apenas uma definição)
function redirecionarPara(pagina) {
    window.location.href = pagina;
}